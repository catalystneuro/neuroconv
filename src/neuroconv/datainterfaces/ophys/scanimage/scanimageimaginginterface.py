import datetime
import json
from typing import Optional
from warnings import warn

from dateutil.parser import parse as dateparse

from ..baseimagingextractorinterface import BaseImagingExtractorInterface
from ....utils import FilePathType


class ScanImageImagingInterface(BaseImagingExtractorInterface):
    """Interface for ScanImage TIFF files."""

    display_name = "ScanImage Imaging"
    associated_suffixes = (".tif",)
    info = "Interface for ScanImage TIFF files."

    ExtractorName = "ScanImageTiffSinglePlaneImagingExtractor"

    @classmethod
    def get_source_schema(cls) -> dict:
        source_schema = super().get_source_schema()
        source_schema["properties"]["file_path"]["description"] = "Path to Tiff file."
        return source_schema

    def __init__(
        self,
        file_path: FilePathType,
        channel_name: Optional[str] = None,
        plane_name: Optional[str] = None,
        fallback_sampling_frequency: Optional[float] = None,  # TODO: to be removed
        verbose: bool = True,
    ):
        """
        DataInterface for reading Tiff files that are generated by ScanImage. This interface extracts the metadata
        from the exif of the tiff file.

        Parameters
        ----------
        file_path: str
            Path to tiff file.
        fallback_sampling_frequency: float, optional
            The sampling frequency can usually be extracted from the scanimage metadata in
            exif:ImageDescription:state.acq.frameRate. If not, use this.
        """
        from roiextractors import ScanImageTiffSinglePlaneImagingExtractor
        from roiextractors.extractors.tiffimagingextractors.scanimagetiff_utils import (
            extract_extra_metadata,
        )

        self.image_metadata = extract_extra_metadata(file_path=file_path)

        # TODO: decide whether to support older versions of ScanImage
        if "state.software.version" in self.image_metadata:
            raise ValueError("This interface is only compatible with ScanImage versions 2020 and later.")

        if fallback_sampling_frequency is not None:
            warn(
                message="Keyword argument 'fallback_sampling_frequency' is deprecated."
                "The sampling frequency extracted from the metadata of the tiff file.",
                category=DeprecationWarning,
            )

        avaliable_channels = ScanImageTiffSinglePlaneImagingExtractor.get_available_channels(file_path=file_path)
        if channel_name is None:
            if len(avaliable_channels) > 1:
                raise ValueError(
                    "More than one channel is detected! Please specify which channel you wish to load "
                    "with the `channel_name` argument. To see which channels are available, use "
                    "`ScanImageTiffSinglePlaneImagingExtractor.get_available_channels(file_path=...)`"
                )
            channel_name = avaliable_channels[0]
        assert channel_name in avaliable_channels, f"Channel {channel_name} not found in the tiff file."

        avaliable_planes = ScanImageTiffSinglePlaneImagingExtractor.get_available_planes(file_path=file_path)
        if plane_name is None:
            if len(avaliable_planes) > 1:
                raise ValueError(
                    "More than one plane is detected! Please specify which plane you wish to load "
                    "with the `plane_name` argument. To see which planes are available, use "
                    "`ScanImageTiffSinglePlaneImagingExtractor.get_available_planes(file_path=...)`"
                )
            plane_name = avaliable_planes[0]
        assert plane_name in avaliable_planes, f"Plane {plane_name} not found in the tiff file."

        super().__init__(file_path=file_path, channel_name=channel_name, plane_name=plane_name, verbose=verbose)

    def get_metadata(self) -> dict:
        device_number = 0  # Imaging plane metadata is a list with metadata for each plane

        metadata = super().get_metadata()

        if "state.internal.triggerTimeString" in self.image_metadata:
            extracted_session_start_time = dateparse(self.image_metadata["state.internal.triggerTimeString"])
            metadata["NWBFile"].update(session_start_time=extracted_session_start_time)
        elif "epoch" in self.image_metadata:
            # Versions of ScanImage at least as recent as 2020, and possibly earlier, store the start time under keyword
            # `epoch`, as a string encoding of a Matlab array, example `'[2022  8  8 16 56 7.329]'`
            # dateparse can't cope with this representation, so using strptime directly
            extracted_session_start_time = datetime.datetime.strptime(
                self.image_metadata["epoch"], "[%Y %m %d %H %M %S.%f]"
            )
            metadata["NWBFile"].update(session_start_time=extracted_session_start_time)

        # Extract many scan image properties and attach them as dic in the description
        ophys_metadata = metadata["Ophys"]
        two_photon_series_metadata = ophys_metadata["TwoPhotonSeries"][device_number]
        if self.image_metadata is not None:
            extracted_description = json.dumps(self.image_metadata)
            two_photon_series_metadata.update(description=extracted_description)

        return metadata
